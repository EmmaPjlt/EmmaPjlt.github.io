<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-React/React-fiber">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.2.0">
<title data-rh="true">React Fiber 介绍 | Alicia</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://emmapjlt.github.io/React/React-fiber"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="React Fiber 介绍 | Alicia"><meta data-rh="true" name="description" content="一、前置条件"><meta data-rh="true" property="og:description" content="一、前置条件"><link data-rh="true" rel="icon" href="/../img/logo.webp"><link data-rh="true" rel="canonical" href="https://emmapjlt.github.io/React/React-fiber"><link data-rh="true" rel="alternate" href="https://emmapjlt.github.io/React/React-fiber" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://emmapjlt.github.io/React/React-fiber" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Alicia RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Alicia Atom Feed"><link rel="stylesheet" href="/assets/css/styles.d35f372e.css">
<link rel="preload" href="/assets/js/runtime~main.1ddade14.js" as="script">
<link rel="preload" href="/assets/js/main.daee84df.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.webp" alt="Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.webp" alt="Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Alicia</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/">文档</a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/">文档</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/category/计算机网络">计算机网络</a><button aria-label="打开/收起侧边栏菜单「计算机网络」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/category/react">React</a><button aria-label="打开/收起侧边栏菜单「React」" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/React/React-fiber">React Fiber 介绍</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/category/算法">算法</a><button aria-label="打开/收起侧边栏菜单「算法」" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/category/react"><span itemprop="name">React</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">React Fiber 介绍</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>React Fiber 介绍</h1></header><h2 class="anchor anchorWithStickyNavbar_LWe7" id="一前置条件">一、前置条件<a class="hash-link" href="#一前置条件" title="标题的直接链接">​</a></h2><blockquote><p>PS：浏览器是多进程的，js 是单线程运行。关于浏览器运行机制，请戳<a href="https://juejin.cn/post/6844903553795014663" target="_blank" rel="noopener noreferrer">这里</a>。</p></blockquote><p>JavaScript 是单线程运行的，而且浏览器要处理的事情非常多，它要负责页面的JS解析和执行、绘制、事件处理、静态资源加载和处理, 这些任务可以类比为’进程‘。</p><blockquote><p>这里特指Javascript 引擎是单线程运行的。 严格来说，Javascript 引擎和页面渲染引擎在同一个渲染线程，GUI 渲染和 Javascript 执行两者是互斥的. 另外异步 I/O 操作底层实际上可能是多线程的在驱动。
<img loading="lazy" alt="image" src="/assets/images/1-ab29b5434c7a00a9cc012e5d8239ff7e.png" width="1093" height="167" class="img_ev3q"></p></blockquote><ul><li>浏览器渲染流程，主流浏览器帧率是 60hz，所以平均 16.6ms 刷新一次，每一帧需要完成的步骤如下：<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">执行 JS 脚本  --  样式布局  --  样式绘制  -- ...</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>如果在执行 JS 脚本的时候占用大量时间，那么浏览器在这一帧将无法进行样式的布局和绘制，导致掉帧，也无法对用户的操作作出响应，体验就会非常差。</li></ul><p>对于前端框架来说，解决问题主要有三种办法：</p><ul><li>优化每个任务，让它要多快有多快。挤压 CPU 的运算量。（真的快）</li><li>快速响应用户，让用户觉得够快，不能阻塞用户的交互。（觉得快）</li><li>尝试 Worker 多线程</li></ul><p>Vue 选择的是第一种，因为 Vue 是基于模版语言，它能精确地进行节点更新（具体大家可以自行搜索尤雨溪之前的演讲）；React 选择的是第二种，所以 React 通过 Fiber 架构，让自己的更新过程变成可中断。 适时让出 CPU 的执行权，让浏览器有时间处理布局以及响应用户的交互。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="二react-15---同步更新">二、React 15 - 同步更新<a class="hash-link" href="#二react-15---同步更新" title="标题的直接链接">​</a></h2><p>架构组成：  </p><ul><li>Reconciler（协调器: 执行 reconcile 算法，也就是我们常说的 diff 算法）—— 负责找出变化的组件。  </li><li>Renderer（渲染器） —— 将变化的组件渲染到页面上。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1reconciler-协调器">1、Reconciler 协调器<a class="hash-link" href="#1reconciler-协调器" title="标题的直接链接">​</a></h3><p>每当有更新发生，Reconciler 会做如下工作：</p><ul><li>调用 render 方法，将返回的 JSX 转化为虚拟 DOM</li><li>将虚拟 DOM 和上次更新时的虚拟 DOM 对比</li><li>通过对比找出本次更新中变化的虚拟 DOM</li><li>通知 Renderer 将变化的虚拟DOM渲染到页面上</li></ul><p><a href="https://zh-hans.reactjs.org/docs/codebase-overview.html#reconciler" target="_blank" rel="noopener noreferrer">官网对 reconciler 的解释</a></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2renderer-渲染器">2、Renderer 渲染器<a class="hash-link" href="#2renderer-渲染器" title="标题的直接链接">​</a></h3><p>我们目前使用的是负责在浏览器环境渲染的 Renderer --- ReactDOM
在每次更新发生时，Renderer 接到 Reconciler通知，将变化的组件渲染在当前宿主环境。</p><p><a href="https://zh-hans.reactjs.org/docs/codebase-overview.html#renderers" target="_blank" rel="noopener noreferrer">官网对 Renderer 的解释</a></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3react-15-架构的弊端">3、React 15 架构的弊端<a class="hash-link" href="#3react-15-架构的弊端" title="标题的直接链接">​</a></h3><p>在 Reconciler 中，mount 的组件会调用 mountComponent，update 的组件会调用 updateComponent。这两个方法都会递归更新子组件。</p><p><a href="https://code.h5jun.com/jaluv/1/edit?html,js,output" target="_blank" rel="noopener noreferrer">react15-demo</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="三react-16---fiber架构异步可中断更新">三、React 16 - Fiber架构，异步可中断更新<a class="hash-link" href="#三react-16---fiber架构异步可中断更新" title="标题的直接链接">​</a></h2><p>React16 架构：</p><ul><li>Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler</li><li>Reconciler（协调器）—— 负责找出变化的组件</li><li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1scheduler除了在空闲时触发回调的功能外scheduler还提供了多种调度优先级供任务设置">1、Scheduler：除了在空闲时触发回调的功能外，Scheduler还提供了多种调度优先级供任务设置。<a class="hash-link" href="#1scheduler除了在空闲时触发回调的功能外scheduler还提供了多种调度优先级供任务设置" title="标题的直接链接">​</a></h3><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback" target="_blank" rel="noopener noreferrer">requestIdleCallback</a> 是一个属于宏任务的回调，就像 setTimeout 一样。不同的是，setTimeout 的执行时机由我们传入的回调时间去控制，requestIdleCallback 是受浏览器的刷新率去控制。它的回调函数可以获取本次可以执行的时间，每一个16ms除了requestIdleCallback 的回调之外，还有其他工作，所以能使用的时间是不确定的，但只要时间到了，就会停下节点的遍历。</p></blockquote><blockquote><p>但由于兼容性不好，加上该回调函数被调用的频率太低，所以 React 自己实现了 polyfill。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2reconciler-协调器">2、Reconciler 协调器<a class="hash-link" href="#2reconciler-协调器" title="标题的直接链接">​</a></h3><p>更新工作从递归变成了可以中断的循环过程。每次循环都会调用 shouldYield 判断当前是否有剩余时间
<img loading="lazy" alt="可中断的循环" src="/assets/images/2-b927ec2bba2fe2af34f3bbfa0ea1cc80.png" width="1240" height="660" class="img_ev3q"></p><p>React16 如何解决中断更新时 DOM 渲染不完全的问题呢？</p><p>在React16中，Reconciler 与 Renderer不再是交替工作。当 Scheduler 将任务交给 Reconciler 后，Reconciler 会为变化的虚拟DOM打上代表增/删/更新的标记</p><p><img loading="lazy" alt="React 中的 Flags" src="/assets/images/3-ddff466e6a63a9513a3fb55b1ead5750.png" width="1240" height="938" class="img_ev3q"></p><p>React 16 架构中更新流程如下
<img loading="lazy" alt="React 16 架构下的更新流程" src="/assets/images/4-a0be1c225fd00601fea9d53299928f1c.png" width="1240" height="520" class="img_ev3q"></p><p>其中红框中的步骤随时可能由于以下原因被中断：</p><ul><li>有其他更高优任务需要先更新</li><li>当前帧没有剩余时间</li></ul><p>整个 Scheduler 与 Reconciler 的工作都在内存中进行。只有当所有组件都完成 Reconciler 的工作，才会统一交给 Renderer。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="四源码目录以及调试源码">四、源码目录以及调试源码<a class="hash-link" href="#四源码目录以及调试源码" title="标题的直接链接">​</a></h2><p>目录：</p><div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">根目录 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> ┣ fixtures        </span><span class="token comment" style="color:#999988;font-style:italic"># 包含一些给贡献者准备的小型 React 测试项目</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> ┣ packages        </span><span class="token comment" style="color:#999988;font-style:italic"># 包含元数据（比如 package.json）和 React 仓库中所有 package 的源码（子目录 src）</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> ┃ ┣ react    </span><span class="token comment" style="color:#999988;font-style:italic"># React的核心，包含所有全局 React API</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> ┃ ┣ scheduler   </span><span class="token comment" style="color:#999988;font-style:italic"># 调度器的实现</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> ┃ ┣ shared   </span><span class="token comment" style="color:#999988;font-style:italic"># 源码中其他模块公用的方法和全局变量</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> ┃ ┣ react-art    </span><span class="token comment" style="color:#999988;font-style:italic"># 渲染器，渲染到Canvas, SVG 或 VML</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> ┃ ┣ react-dom      </span><span class="token comment" style="color:#999988;font-style:italic"># 渲染器，在浏览器环境渲染</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> ┃ ┣ react-native-renderer   </span><span class="token comment" style="color:#999988;font-style:italic">#  渲染器，渲染App原生组件</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> ┃ ┣ react-reconciler   </span><span class="token comment" style="color:#999988;font-style:italic"># 协调器，diff 算法</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> ┗ scripts        </span><span class="token comment" style="color:#999988;font-style:italic"># 各种工具链的脚本，比如git、jest、eslint等</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>调试源码：</p><blockquote><p>1、下载源码，并对 <code>react</code>，<code>react-dom</code> 进行 build
2、使用 <code>npm link</code> 改变依赖包的目录指向
3、本地建一个 react 项目，将 <code>react</code> 与 <code>react-dom</code> 2个包指向我们刚才生成的包</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="五jsx">五、JSX<a class="hash-link" href="#五jsx" title="标题的直接链接">​</a></h2><p><a href="https://babeljs.io/repl/#?browsers=&amp;build=&amp;builtIns=false&amp;corejs=3.21&amp;spec=false&amp;loose=false&amp;code_lz=FAHgJglgbgBAzgFwJ4BsCmBeA3lgxgexXwCcAuGAcmLTAoF86A-ARgCYBmEAekikaA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=true&amp;fileSize=false&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=false&amp;presets=es2015%2Creact%2Cstage-2&amp;prettier=false&amp;targets=&amp;version=7.20.4&amp;externalPlugins=&amp;assumptions=%7B%7D" target="_blank" rel="noopener noreferrer">babel 在线编译</a></p><p><img loading="lazy" alt="babel 编译 JSX" src="/assets/images/5-06dcb8af0292bc4b17739f17ac88fd98.png" width="1240" height="209" class="img_ev3q"></p><p>通过上图可以发现，JSX 会被 babel 编译为 React.createElement，这也就是为什么我们每个使用 JSX 的 JS 文件中，都必须显式的声明 React。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import React from &#x27;react&#x27;;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>JSX 并不是只能被编译为 React.createElement 方法，可以通过插件或者注释告诉 babel 用哪个方法进行编译。</p><p><img loading="lazy" alt="使用别的方法编译 JSX" src="/assets/images/6-5497f1eb254490543c7f5bf30717ef2e.png" width="1202" height="1066" class="img_ev3q"></p><p>结论：JSX 是一种描述当前组件内容的数据结构，他不包含组件 schedule、reconcile、render 所需的相关信息。
比如如下信息就不包括在JSX中：</p><ul><li>组件在更新中的优先级</li><li>组件的state</li><li>组件被打上的用于Renderer的标记
这些内容都包含在虚拟DOM中。</li></ul><p>所以，在组件<code>mount</code>时，<code>Reconciler</code>根据<code>JSX</code>描述的组件内容生成组件对应的<code>虚拟DOM</code>。</p><p>在<code>update</code>时，<code>Reconciler</code>将<code>JSX</code>与<code>虚拟DOM</code>保存的数据对比，生成组件对应的<code>虚拟DOM</code>，并根据对比结果为<code>虚拟DOM</code>打上<code>标记</code>。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="六fiber">六、Fiber<a class="hash-link" href="#六fiber" title="标题的直接链接">​</a></h2><ul><li>起源：为了实现异步可中断的架构。</li></ul><p>什么是异步可中断？（以 Generator 为例，普通函数并没办法中断，但是 Generator 可以）</p><p>Fiber 的思想即如此，React 执行的过程可以被中断，把控制权交还给浏览器，让位给高优先级的任务，等浏览器空闲的时候再继续 React 的渲染。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1主动让出机制">1、主动让出机制<a class="hash-link" href="#1主动让出机制" title="标题的直接链接">​</a></h3><p>一是浏览器不具备中断/恢复的条件。<br>
<!-- -->二是没有抢占的机制，我们无法中断一个正在执行的程序。</p><p>把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行。这就叫合作式调度（操作系统常用的任务调度策略之一）</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2requestidlecallback">2、requestIdleCallback<a class="hash-link" href="#2requestidlecallback" title="标题的直接链接">​</a></h3><p>该 Api 主要是让浏览器在&#x27;有空&#x27;的时候就执行我们的回调，这个回调会传入一个期限，表示浏览器有多少时间供我们执行, 为了不耽误事，我们最好在这个时间范围内执行完毕。 </p><p>但因为缺陷很多，React 自己实现了 Scheduler 库来实现这个目标。</p><p>React 预订了几个优先级，如下，每个优先级对应的事件不同，这里先简单了解一下。</p><p><img loading="lazy" alt="优先级.png" src="/assets/images/7-1060a5fabe0a7c6e0b49639efbe5e036.png" width="1240" height="290" class="img_ev3q"></p><p><img loading="lazy" alt="优先级释义" src="/assets/images/8-91ea480663163f71102125b782dbaa2e.png" width="1240" height="336" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3为什么不用-generator">3、为什么不用 Generator<a class="hash-link" href="#3为什么不用-generator" title="标题的直接链接">​</a></h3><ul><li>Generator 是会产生连锁反应的，类似于 async..await，它需要把每层函数都包装成 Generator</li><li>Generator 是有状态的，中断后很难恢复</li></ul><p>简单来讲就是，React 可能尝试过，但发现过于麻烦于是放弃了，详情请看 <a href="https://github.com/facebook/react/issues/7942" target="_blank" rel="noopener noreferrer">React 官方说法</a></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="4fiber-的三层含义">4、Fiber 的三层含义<a class="hash-link" href="#4fiber-的三层含义" title="标题的直接链接">​</a></h3><ul><li><ol><li>作为架构来说，之前 React15 的 Reconciler 采用递归的方式执行，数据保存在递归调用栈中，所以被称为 <code>stack Reconciler</code>。React16 的 Reconciler 基于 Fiber 节点实现，被称为 <code>Fiber Reconciler</code>。<blockquote><p>作为架构来说，每个 Fiber 节点对应一个组件，多个 Fiber 节点如何连接成树呢，靠以下三个属性</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 指向父级Fiber节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">this.return = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 指向子Fiber节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">this.child = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 指向右边第一个兄弟Fiber节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">this.sibling = null;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>  举个例子，如下的组件结构：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function App() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;div&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      i am</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &lt;span&gt;a span&lt;/span&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;/div&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>  其对应的 Fiber 树的架构如下
<img loading="lazy" alt="Fiber" src="/assets/images/9-715eb012c566437264b3ebd42c03839d.png" width="980" height="908" class="img_ev3q"></p></blockquote></li></ol></li></ul><blockquote><p>之所以父节点使用 return，因为作为一个工作单元，return指节点执行完completeWork（后面会介绍）后会返回的下一个节点。子Fiber节点及其兄弟节点完成工作后会返回其父级节点，所以用return指代父级节点 。</p></blockquote><ul><li><ol start="2"><li>作为静态的数据结构来说，每个 Fiber 节点对应一个组件，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的 DOM 节点等信息，即我们常说的虚拟 DOM。</li></ol></li><li><ol start="3"><li>作为动态的工作单元来说，每个 Fiber 节点保存了本次更新中该组件改变的状态、要执行的副作用(effectTag)（需要被删除/被插入页面中/被更新...）。</li></ol></li></ul><p><img loading="lazy" alt="fiber node 属性" src="/assets/images/10-9845ddc255110fd5ac946200cebb6be7.png" width="1152" height="1108" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5双缓存">5、双缓存<a class="hash-link" href="#5双缓存" title="标题的直接链接">​</a></h3><p>上面了解到 Fiber 的起源与架构，其中 Fiber 节点可以构成 Fiber 树。那么 Fiber 树和页面呈现的 DOM 树有什么关系，React 又是如何更新 DOM 的呢？</p><p><strong>在内存中构建并直接替换</strong>的技术叫做<a href="https://baike.baidu.com/item/%E5%8F%8C%E7%BC%93%E5%86%B2" target="_blank" rel="noopener noreferrer">双缓存</a>。</p><p>打个比方：当我们用canvas绘制动画，每一帧绘制前都会调用 ctx.clearRect 清除上一帧的画面。如果当前帧画面计算量比较大，导致清除上一帧画面到绘制当前帧画面之间有较长间隙，就会出现白屏闪烁。
为了解决这个问题，我们可以在内存中绘制当前帧动画，绘制完毕后直接用当前帧替换上一帧画面，由于省去了两帧替换间的计算时间，不会出现从白屏到出现画面的闪烁情况。</p><p>React 就是使用双缓存来完成 Fiber 树的构建和替换 -- 也就对应着 DOM 树的创建和更新。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="双缓存-fiber-树">双缓存 Fiber 树<a class="hash-link" href="#双缓存-fiber-树" title="标题的直接链接">​</a></h4><p>在 <code>React</code> 中最多会同时存在两棵 <code>Fiber</code> 树。当前屏幕上显示内容对应的 <code>Fiber</code> 树称为 <code>current Fiber</code> 树，正在内存中构建的 <code>Fiber</code> 树称为 <code>workInProgress Fiber</code> 树；</p><p><code>current Fiber</code> 树中的 <code>Fiber</code> 节点被称为 <code>current fiber</code>，<code>workInProgress Fiber</code> 树中的 <code>Fiber</code> 节点被称为 <code>workInProgress fiber</code>，他们通过 <code>alternate</code> 属性连接。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function App() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const [num, setNum] = useState(0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;p onclick={()=&gt;setNum(num+1)}&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      {num}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;/p&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ReactDom.render(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &lt;App/&gt;, document.getElementById(&#x27;root&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><img loading="lazy" alt="image.png" src="/assets/images/11-f654271bd96b56f2059dc7c03db718ad.png" width="888" height="960" class="img_ev3q"></p><p>我们目前拥有两颗 Fiber 树，左侧代表页面内容的 Fiber 树，称为 <code>current Fiber</code> 树，右侧是触发更新的时候，在内存中构建的 Fiber 树，称为 <code>workInProgress Fiber</code> 树，当 <code>workInProgress Fiber</code> 树完成了渲染，此时根 <code>fiber</code> 的 <code>current</code> 指针就会指向 <code>workInProgress Fiber</code> 树的根节点，此时，<code>workInProgress Fiber</code> 树就变成了<code>current Fiber</code> 树，；</p><p><img loading="lazy" alt="image.png" src="/assets/images/12-b54a97e85c01754e2b374d7134e07287.png" width="1240" height="406" class="img_ev3q"></p><p><img loading="lazy" alt="image.png" src="/assets/images/13-f9267304558d9378f0acc495cbf32bcf.png" width="850" height="914" class="img_ev3q"></p><p>以上就是mount阶段发生的事情；那么在update阶段发生了什么呢？</p><p>mount 阶段完成后，我们 <code>current Fiber</code> 树就已经存在了，<code>current Fiber</code> 树的 <code>alternate</code> 指针就指向当前的 <code>workInProgress Fiber</code> 树；当我们点击 p 标签，state 发生变化的时候就会触发 update，每次更新的时候，都会重新创建一个 <code>workInProgress Fiber</code> 树，会基于当前 Fiber 节点来创建。（更新会返回新的 jsx，把 jsx 对象和 current Fiber 做比较生成 workInprogress Fiber 树，这个过程就是我们常说的 Diff 算法）</p><p><img loading="lazy" alt="image.png" src="/assets/images/14-8954bbcdd9eb7a8bbfeb079b68108340.png" width="910" height="970" class="img_ev3q"></p><blockquote><p>所以，首屏渲染和更新最大的区别就是，有没有进行 Diff 算法。</p></blockquote><blockquote><p>生成 <code>workInProgress Fiber</code> 节点的时候，会适时复用 <code>current Fiber</code> 节点，什么时候复用就是 Diff 算法做的事情</p></blockquote></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-tags-row row margin-bottom--sm"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/react">React</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/fiber">Fiber</a></li></ul></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/category/react"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">React</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/category/算法"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">算法</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#一前置条件" class="table-of-contents__link toc-highlight">一、前置条件</a></li><li><a href="#二react-15---同步更新" class="table-of-contents__link toc-highlight">二、React 15 - 同步更新</a><ul><li><a href="#1reconciler-协调器" class="table-of-contents__link toc-highlight">1、Reconciler 协调器</a></li><li><a href="#2renderer-渲染器" class="table-of-contents__link toc-highlight">2、Renderer 渲染器</a></li><li><a href="#3react-15-架构的弊端" class="table-of-contents__link toc-highlight">3、React 15 架构的弊端</a></li></ul></li><li><a href="#三react-16---fiber架构异步可中断更新" class="table-of-contents__link toc-highlight">三、React 16 - Fiber架构，异步可中断更新</a><ul><li><a href="#1scheduler除了在空闲时触发回调的功能外scheduler还提供了多种调度优先级供任务设置" class="table-of-contents__link toc-highlight">1、Scheduler：除了在空闲时触发回调的功能外，Scheduler还提供了多种调度优先级供任务设置。</a></li><li><a href="#2reconciler-协调器" class="table-of-contents__link toc-highlight">2、Reconciler 协调器</a></li></ul></li><li><a href="#四源码目录以及调试源码" class="table-of-contents__link toc-highlight">四、源码目录以及调试源码</a></li><li><a href="#五jsx" class="table-of-contents__link toc-highlight">五、JSX</a></li><li><a href="#六fiber" class="table-of-contents__link toc-highlight">六、Fiber</a><ul><li><a href="#1主动让出机制" class="table-of-contents__link toc-highlight">1、主动让出机制</a></li><li><a href="#2requestidlecallback" class="table-of-contents__link toc-highlight">2、requestIdleCallback</a></li><li><a href="#3为什么不用-generator" class="table-of-contents__link toc-highlight">3、为什么不用 Generator</a></li><li><a href="#4fiber-的三层含义" class="table-of-contents__link toc-highlight">4、Fiber 的三层含义</a></li><li><a href="#5双缓存" class="table-of-contents__link toc-highlight">5、双缓存</a></li></ul></li></ul></div></div></div></div></main></div></div></div>
<script src="/assets/js/runtime~main.1ddade14.js"></script>
<script src="/assets/js/main.daee84df.js"></script>
</body>
</html>